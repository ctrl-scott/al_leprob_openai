/* Offline Learning — Minimal JS controller
   Notes:
   - No external dependencies.
   - All progress is stored in localStorage under the key 'ol_progress'.
   - Strings and comments avoid contractions as requested.
*/

(function () {
  "use strict";

  // ========= Utilities first =========
  function escapeHtml(str) {
    return String(str)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function escapeAttr(str) {
    return String(str)
      .replaceAll("&", "&amp;")
      .replaceAll('"', "&quot;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll("'", "&#039;");
  }

  function renderLink(b) {
    const href = b && b.href ? escapeAttr(b.href) : "#";
    const download = b && b.download ? " download" : "";
    const target = b && b.newTab ? ' target="_blank" rel="noopener"' : "";
    const label = b && b.text ? escapeHtml(b.text) : href;
    return `<p><a href="${href}"${download}${target}>${label}</a></p>`;
  }

  // ---------- Extra block renderers ----------
  function renderImg(b) {
    const alt = escapeAttr(b.alt || "");
    return `<p><img src="${escapeAttr(b.src)}" alt="${alt}" style="max-width:100%;height:auto"/></p>`;
  }

  function renderSvg(b) {
    // external: hydrate later; inline: use markup
    if (b.src) return `<div class="svg-wrap" data-src="${escapeAttr(b.src)}"></div>`;
    return `<div class="svg-wrap">${b.markup || ""}</div>`;
  }

  async function hydrateSvg() {
    const holders = document.querySelectorAll(".svg-wrap[data-src]");
    for (const el of holders) {
      const src = el.getAttribute("data-src");
      try {
        const res = await fetch(src);
        el.innerHTML = await res.text();
      } catch {
        el.innerHTML = `<img src="${escapeAttr(src)}" alt="" style="max-width:100%;height:auto"/>`;
      }
    }
  }

  function renderAudio(b) {
    const cap = b.caption ? `<div class="note">${escapeHtml(b.caption)}</div>` : "";
    return `<div><audio controls preload="metadata" src="${escapeAttr(b.src)}"></audio>${cap}</div>`;
  }

  function renderNumberLine(b) {
    const min = b.min ?? 0, max = b.max ?? 10, tickEvery = b.tickEvery ?? 1;
    const width = 300, height = 50, pad = 20;
    const range = Math.max(1, max - min); // guard for min==max
    const ticks = [];
    for (let v = min; v <= max; v += tickEvery) {
      const x = pad + ((v - min) / range) * (width - 2 * pad);
      ticks.push(`<line x1="${x}" y1="20" x2="${x}" y2="35" stroke="currentColor"/>`);
      ticks.push(`<text x="${x}" y="48" font-size="12" text-anchor="middle">${v}</text>`);
    }
    const targetX = b.target != null ? pad + ((b.target - min) / range) * (width - 2 * pad) : null;
    const target = (targetX != null)
      ? `<circle cx="${targetX}" cy="10" r="4" fill="currentColor"/>${b.showTargetLabel ? `<text x="${targetX}" y="10" dy="-6" font-size="12" text-anchor="middle">${b.target}</text>` : ""}`
      : "";
    return `<svg viewBox="0 0 ${width} ${height}" role="img" aria-label="Number line ${min} to ${max}">
      <line x1="${pad}" y1="20" x2="${width - pad}" y2="20" stroke="currentColor"/>
      ${ticks.join("")}
      ${target}
    </svg>`;
  }

  function renderTenFrame(b) {
    const value = Math.max(0, Math.min(10, Number(b.value || 0)));
    const cells = Array.from({ length: 10 }, (_, i) =>
      `<div class="cell" aria-label="slot ${i + 1}">${i < value ? "●" : ""}</div>`
    ).join("");
    return `<div class="tenframe" role="group" aria-label="${escapeAttr(b.label || "Ten frame")}">${cells}</div>`;
  }

  function renderPhoneme(b) {
    const ex = (b.examples || []).map(e =>
      `<button class="btn small" data-audio="${escapeAttr(e.audio)}">${escapeHtml(e.word)}</button>`
    ).join(" ");
    const mp = (b.minimalPairs || []).map(p =>
      `<div class="card"><button class="btn small" data-audio="${escapeAttr(p.audioA)}">${escapeHtml(p.pair[0])}</button>
       <button class="btn small" data-audio="${escapeAttr(p.audioB)}">${escapeHtml(p.pair[1])}</button></div>`
    ).join("");
    return `<div class="phoneme">
      <div><strong>${escapeHtml(b.grapheme)}</strong> /${escapeHtml(b.ipa || "")}/</div>
      <div class="examples">${ex}</div>
      <div class="pairs">${mp}</div>
    </div>`;
  }

  // Global handler for audio buttons
  document.addEventListener("click", (e) => {
    const a = e.target.closest("[data-audio]");
    if (!a) return;
    const src = a.getAttribute("data-audio");
    const audio = new Audio(src);
    audio.play().catch(() => {});
  });

  // ================== App state and selectors ==================
  const SELECTORS = {
    views: ".view",
    moduleList: "#modules-list",
    lessonArticle: "#lesson-article",
    quizArea: "#quiz-area",
    progressSummary: "#progress-summary",
    moduleSearch: "#module-search",
    homeSuggestions: "#home-suggestions",
  };

  const STATE = {
    modulesIndex: null,
    currentModule: null,
    currentLesson: null,
    progress: loadProgress(),

    // caches
    moduleLessons: {},            // moduleId -> [lessons]
    moduleQuizzesByLesson: {},    // moduleId -> { lessonId: [rootQuestions] }
    quizIndexByLesson: {}         // moduleId -> { lessonId: number }
  };

  // ================== View switching / global clicks ==================
  document.addEventListener("click", function (e) {
    const t = e.target;

    // View buttons
    if (t.matches("[data-view]")) {
      const view = t.getAttribute("data-view");
      showView(view);
      return;
    }
    if (t.id === "back-to-modules") {
      showView("modules");
      return;
    }

    // Open module
    if (t && t.dataset && t.dataset.action === "open-module" && t.dataset.module) {
      openModule(t.dataset.module);
      return;
    }

    // Lesson pagination
    if (t && t.id === "prev-lesson" && t.dataset.go) { goToLesson(t.dataset.go); return; }
    if (t && t.id === "next-lesson" && t.dataset.go) { goToLesson(t.dataset.go); return; }

    // Quiz pagination
    if (t && t.id === "quiz-prev") {
      const modId = STATE.currentModule.id;
      const lessonId = STATE.currentLesson.id;
      const all = collectQuizzesForLesson(STATE.currentLesson);
      const i = getQuizIndex(modId, lessonId);
      if (i > 0) {
        setQuizIndex(modId, lessonId, i - 1);
        renderQuiz(STATE.currentLesson);
      }
      return;
    }
    if (t && t.id === "quiz-next") {
      const modId = STATE.currentModule.id;
      const lessonId = STATE.currentLesson.id;
      const all = collectQuizzesForLesson(STATE.currentLesson);
      const i = getQuizIndex(modId, lessonId);
      if (i < all.length - 1) {
        setQuizIndex(modId, lessonId, i + 1);
        renderQuiz(STATE.currentLesson);
      }
      return;
    }

    // Export / Import / Clear
    if (t && t.id === "export-progress") {
      const blob = new Blob([JSON.stringify(STATE.progress, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "offline_learning_progress.json";
      a.click();
      URL.revokeObjectURL(url);
      return;
    }
    if (t && t.id === "clear-progress") {
      if (confirm("This will erase local progress on this device. Proceed?")) {
        STATE.progress = { visited: {}, answers: {} };
        saveProgress();
        renderProgress();
      }
      return;
    }
    if (t && t.id === "import-progress") {
      const file = document.getElementById("import-file").files[0];
      if (!file) { alert("Please select a file to import."); return; }
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const data = JSON.parse(reader.result);
          if (data && typeof data === "object") {
            STATE.progress = data;
            saveProgress();
            alert("Progress imported successfully.");
            renderProgress();
          }
        } catch (err) {
          alert("Import failed. The file did not contain valid JSON.");
        }
      };
      reader.readAsText(file);
      return;
    }
  });

  function showView(view) {
    document.querySelectorAll(SELECTORS.views).forEach(v => {
      const shouldShow = v.dataset.view === view;
      v.hidden = !shouldShow;
    });
    const main = document.getElementById("main");
    if (main) main.focus();
    if (view === "modules") renderModules();
    if (view === "progress") renderProgress();
  }

  // ================== Initial load ==================
  window.addEventListener("DOMContentLoaded", async () => {
    await loadModulesIndex();
    showView("home");
    wireSearch();
    renderHomeSuggestions();
  });

  async function loadModulesIndex() {
    try {
      const res = await fetch("modules/index.json");
      STATE.modulesIndex = await res.json();
    } catch (err) {
      console.error("Failed to load modules index:", err);
      STATE.modulesIndex = { modules: [] };
    }
  }

  function renderHomeSuggestions() {
    const container = document.querySelector(SELECTORS.homeSuggestions);
    if (!container) return;
    container.innerHTML = "";
    const pool = (STATE.modulesIndex.modules || []).slice(0, 6);
    pool.forEach(mod => container.appendChild(renderModuleCard(mod)));
  }

  function renderModules(filterText = "") {
    const list = document.querySelector(SELECTORS.moduleList);
    if (!list) return;
    list.innerHTML = "";
    const items = (STATE.modulesIndex.modules || []).filter(m => {
      if (!filterText) return true;
      const t = filterText.toLowerCase();
      return (
        m.id.toLowerCase().includes(t) ||
        m.title.toLowerCase().includes(t) ||
        (m.tags || []).join(" ").toLowerCase().includes(t)
      );
    });
    if (items.length === 0) {
      const empty = document.createElement("p");
      empty.textContent = "No modules matched your search.";
      list.appendChild(empty);
      return;
    }
    items.forEach(m => list.appendChild(renderModuleCard(m)));
  }

  function renderModuleCard(mod) {
    const card = document.createElement("div");
    card.className = "card";
    card.innerHTML = `
      <h3>${escapeHtml(mod.title)}</h3>
      <p>${escapeHtml(mod.description || "")}</p>
      <p class="note">Lessons: ${mod.lesson_count ?? "Unknown"}</p>
      <div style="display:flex; gap:.5rem; flex-wrap:wrap; margin-top:.25rem;">
        <button class="btn small" data-action="open-module" data-module="${mod.id}">Open</button>
      </div>
    `;
    return card;
  }

  // ---------- Root-level quizzes map ----------
  function buildQuizMap(quizzes) {
    const map = {};
    if (!Array.isArray(quizzes)) return map;
    for (const qset of quizzes) {
      const lid = qset && qset.lesson_id;
      if (!lid) continue;
      const arr = Array.isArray(qset.questions) ? qset.questions : [];
      map[lid] = arr;
    }
    return map;
  }

  async function openModule(moduleId) {
    const mod = (STATE.modulesIndex.modules || []).find(m => m.id === moduleId);
    if (!mod) return;
    STATE.currentModule = mod;
    try {
      const res = await fetch(`modules/${moduleId}/lessons.json`);
      const data = await res.json();

      const lessons = Array.isArray(data.lessons) ? data.lessons : [];
      STATE.moduleLessons[moduleId] = lessons;

      STATE.moduleQuizzesByLesson[moduleId] = buildQuizMap(data.quizzes || []);

      if (lessons.length) {
        renderLesson(lessons[0], lessons);
      } else {
        alert("Module has no lessons defined.");
      }
      showView("lesson");
    } catch (err) {
      console.error("Failed to load lessons:", err);
      alert("Could not load lessons for this module.");
    }
  }

  function renderLesson(lesson, collection) {
    STATE.currentLesson = lesson;
    const el = document.querySelector(SELECTORS.lessonArticle);
    if (!el) return;
    el.innerHTML = `
      <header>
        <h2>${escapeHtml(lesson.title)}</h2>
        <p class="meta">Module: ${escapeHtml(STATE.currentModule.title)} — Level: ${escapeHtml(lesson.level || "General")}</p>
      </header>
      <section class="content">${renderBlocks(lesson.content)}</section>
      <nav class="lesson-nav">
        ${renderLessonNav(lesson, collection)}
      </nav>
    `;

    // Initialize quiz index for this lesson if missing
    const modId = STATE.currentModule.id;
    if (STATE.quizIndexByLesson?.[modId]?.[lesson.id] == null) {
      setQuizIndex(modId, lesson.id, 0);
    }

    hydrateSvg();       // hydrate any external SVGs
    renderQuiz(lesson); // draw quiz
    markVisited(STATE.currentModule.id, lesson.id);
  }

  function renderBlocks(blocks) {
    if (!Array.isArray(blocks)) return "";
    return blocks.map(b => {
      if (b.type === "a") return renderLink(b);
      if (b.type === "p") return `<p>${escapeHtml(b.text)}</p>`;
      if (b.type === "ul") return `<ul>${b.items.map(it => `<li>${escapeHtml(it)}</li>`).join("")}</ul>`;
      if (b.type === "ol") return `<ol>${b.items.map(it => `<li>${escapeHtml(it)}</li>`).join("")}</ol>`;
      if (b.type === "code") return `<pre><code>${escapeHtml(b.code)}</code></pre>`;
      if (b.type === "h3") return `<h3>${escapeHtml(b.text)}</h3>`;
      if (b.type === "img") return renderImg(b);
      if (b.type === "svg") return renderSvg(b);
      if (b.type === "audio") return renderAudio(b);
      if (b.type === "numberline") return renderNumberLine(b);
      if (b.type === "tenframe") return renderTenFrame(b);
      if (b.type === "phoneme") return renderPhoneme(b);
      return "";
    }).join("");
  }

  function renderLessonNav(current, collection) {
    const idx = collection.findIndex(x => x.id === current.id);
    const prev = idx > 0 ? collection[idx - 1] : null;
    const next = idx < collection.length - 1 ? collection[idx + 1] : null;
    return `
      <div style="display:flex; gap:.5rem; margin-top:.5rem;">
        <button class="btn small" ${prev ? "" : "disabled"} data-go="${prev ? prev.id : ""}" id="prev-lesson">Previous</button>
        <button class="btn small" ${next ? "" : "disabled"} data-go="${next ? next.id : ""}" id="next-lesson">Next</button>
      </div>
    `;
  }

  async function goToLesson(lessonId) {
    try {
      const lessons = STATE.moduleLessons[STATE.currentModule.id] || [];
      const target = lessons.find(x => x.id === lessonId);
      if (target) renderLesson(target, lessons);
    } catch (err) {
      console.error("Navigation failed:", err);
    }
  }

  // ---------- Quiz adapters / pagination ----------
  function adaptQuizShape(q) {
    if (!q || typeof q !== "object") return null;
    const prompt = q.prompt ?? q.question ?? q.text ?? null;
    const choices = q.choices ?? q.options ?? q.answers ?? null;
    const answer = (typeof q.answerIndex === "number") ? q.answerIndex : q.answer;
    if (!prompt || !Array.isArray(choices) || typeof answer !== "number") return null;
    return { prompt, choices, answer };
  }

  function collectQuizzesForLesson(lesson) {
    const arr = [];
    const add = (x) => { const a = adaptQuizShape(x); if (a) arr.push(a); };

    if (lesson?.quiz) add(lesson.quiz);
    if (Array.isArray(lesson?.quizzes)) lesson.quizzes.forEach(add);
    if (Array.isArray(lesson?.questions)) lesson.questions.forEach(add);

    const modId = STATE.currentModule?.id;
    const root = STATE.moduleQuizzesByLesson?.[modId]?.[lesson?.id];
    if (Array.isArray(root)) root.forEach(add);

    return arr; // unified [{prompt,choices,answer}, ...]
  }

  function getQuizIndex(moduleId, lessonId) {
    return STATE.quizIndexByLesson?.[moduleId]?.[lessonId] ?? 0;
  }
  function setQuizIndex(moduleId, lessonId, idx) {
    if (!STATE.quizIndexByLesson[moduleId]) STATE.quizIndexByLesson[moduleId] = {};
    STATE.quizIndexByLesson[moduleId][lessonId] = idx;
  }

  function renderQuiz(lesson) {
    const area = document.querySelector(SELECTORS.quizArea);
    if (!area) return;

    const modId = STATE.currentModule.id;
    const all = collectQuizzesForLesson(lesson);
    if (!all.length) { area.innerHTML = ""; return; }

    // Clamp cursor
    let idx = Math.max(0, Math.min(getQuizIndex(modId, lesson.id), all.length - 1));
    setQuizIndex(modId, lesson.id, idx);

    const q = all[idx];
    const userAns = getAnswer(modId, lesson.id, idx);

    const atFirst = idx === 0;
    const atLast = idx === all.length - 1;

    area.innerHTML = `
      <h3>Check Your Understanding</h3>
      <div class="quiz-meta" style="display:flex;align-items:center;gap:.5rem;margin:.25rem 0 .5rem 0;">
        <button class="btn small" id="quiz-prev" ${atFirst ? "disabled" : ""}>Previous</button>
        <span class="note">Question ${idx + 1} of ${all.length}</span>
        <button class="btn small" id="quiz-next" ${atLast ? "disabled" : ""}>Next</button>
      </div>

      <p>${escapeHtml(q.prompt)}</p>

      <div class="choices" role="radiogroup" aria-label="Quiz choices">
        ${q.choices.map((c, i) => {
          const checked = userAns === i ? 'aria-checked="true"' : 'aria-checked="false"';
          return `<div class="choice" role="radio" tabindex="0" data-index="${i}" ${checked}>${escapeHtml(c)}</div>`;
        }).join("")}
      </div>

      <div class="result" id="quiz-result" aria-live="polite"></div>
    `;

    // Wire choice interactions
    area.querySelectorAll(".choice").forEach(el => {
      el.addEventListener("click", () => selectChoice(el, q.answer, idx));
      el.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter" || ev.key === " ") { ev.preventDefault(); selectChoice(el, q.answer, idx); }
      });
    });

    // Show previous result if any
    if (typeof userAns === "number") {
      showQuizResult(userAns === q.answer);
    }
  }

  function selectChoice(el, correctIndex, quizIndex) {
    const idx = Number(el.dataset.index);
    el.parentElement.querySelectorAll(".choice").forEach(n => n.setAttribute("aria-checked", "false"));
    el.setAttribute("aria-checked", "true");
    const modId = STATE.currentModule.id;
    const lessonId = STATE.currentLesson.id;
    const qIdx = (typeof quizIndex === "number") ? quizIndex : getQuizIndex(modId, lessonId);
    setAnswer(modId, lessonId, idx, qIdx);
    showQuizResult(idx === correctIndex);
  }

  function showQuizResult(isCorrect) {
    const rr = document.getElementById("quiz-result");
    if (!rr) return;
    rr.textContent = isCorrect ? "Correct." : "Not correct. Please review the lesson and try again.";
  }

  // ---------- Progress handling ----------
  function loadProgress() {
    try {
      return JSON.parse(localStorage.getItem("ol_progress")) || { visited: {}, answers: {} };
    } catch {
      return { visited: {}, answers: {} };
    }
  }
  function saveProgress() {
    localStorage.setItem("ol_progress", JSON.stringify(STATE.progress));
  }
  function markVisited(moduleId, lessonId) {
    if (!STATE.progress.visited[moduleId]) STATE.progress.visited[moduleId] = {};
    STATE.progress.visited[moduleId][lessonId] = true;
    saveProgress();
  }

  // Store per-question answers; keep backward compatibility with scalar saves
  function setAnswer(moduleId, lessonId, ansIndex, qIndex = 0) {
    if (!STATE.progress.answers[moduleId]) STATE.progress.answers[moduleId] = {};
    const existing = STATE.progress.answers[moduleId][lessonId];

    // Upgrade older scalar to object {0: value}
    if (typeof existing === "number") {
      STATE.progress.answers[moduleId][lessonId] = { 0: existing };
    } else if (!existing || typeof existing !== "object") {
      STATE.progress.answers[moduleId][lessonId] = {};
    }

    STATE.progress.answers[moduleId][lessonId][qIndex] = ansIndex;
    saveProgress();
  }

  function getAnswer(moduleId, lessonId, qIndex = 0) {
    const v = STATE.progress.answers?.[moduleId]?.[lessonId];
    if (typeof v === "number") {
      // old saves: single answer -> treat as question 0 only
      return qIndex === 0 ? v : undefined;
    }
    return v?.[qIndex];
  }

  function renderProgress() {
    const box = document.querySelector(SELECTORS.progressSummary);
    if (!box) return;
    box.innerHTML = "";
    const mods = STATE.modulesIndex.modules || [];
    mods.forEach(m => {
      const visited = Object.keys(STATE.progress.visited[m.id] || {}).length;
      const total = m.lesson_count || 0;
      const card = document.createElement("div");
      card.className = "card";
      card.innerHTML = `<h3>${escapeHtml(m.title)}</h3><p>${visited} of ${total} lessons visited.</p>`;
      box.appendChild(card);
    });
  }

  // ---------- Search ----------
  function wireSearch() {
    const input = document.querySelector(SELECTORS.moduleSearch);
    if (!input) return;
    input.addEventListener("input", (e) => {
      const value = e.target.value.trim();
      renderModules(value);
    });
  }

})();
