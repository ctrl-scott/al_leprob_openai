<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Online Reader MVP (Plain‚ÄëText ‚Ä¢ Public Domain)</title>
  <style>
    /* ===============================
       RESET AND THEME TOKENS
       =============================== */
    :root {
      --bg: #ffffff;
      --fg: #111111;
      --muted: #6b7280;
      --link: #1d4ed8;
      --border: #e5e7eb;
      --accent: #0ea5e9;

      --font-size: 18px;
      --line-height: 1.6;
      --page-max: 70ch; /* comfortable measure */
      --pad: 1rem;
    }

    [data-theme="dark"] {
      --bg: #0b0f14;
      --fg: #e5e7eb;
      --muted: #a3a3a3;
      --link: #60a5fa;
      --border: #1f2937;
      --accent: #22d3ee;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: var(--bg);
      color: var(--fg);
      font-family: ui-serif, Georgia, Cambria, "Times New Roman", Times, serif;
      font-size: var(--font-size);
      line-height: var(--line-height);
    }

    *, *::before, *::after { box-sizing: border-box; }
    a { color: var(--link); }

    /* ===============================
       LAYOUT
       =============================== */
    .app {
      display: grid;
      grid-template-rows: auto 1fr auto;
      grid-template-columns: 280px 1fr;
      grid-template-areas:
        "header header"
        "sidebar main"
        "footer footer";
      min-height: 100vh;
    }

    header {
      grid-area: header;
      display: flex;
      align-items: center;
      gap: .75rem;
      padding: .5rem var(--pad);
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      background: var(--bg);
      z-index: 10;
    }

    header .title {
      font-weight: 700;
      margin-right: auto;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 45vw;
    }

    header .controls { display: flex; gap: .5rem; align-items: center; }
    select, input[type="search"], button {
      font: inherit;
      color: var(--fg);
      background: transparent;
      border: 1px solid var(--border);
      border-radius: .5rem;
      padding: .4rem .6rem;
    }
    button.icon { width: 2.25rem; height: 2.25rem; display: inline-grid; place-items: center; }

    aside {
      grid-area: sidebar;
      border-right: 1px solid var(--border);
      min-height: 0; /* allow child to scroll */
      display: grid;
      grid-template-rows: auto 1fr;
    }
    .tabs { display: flex; border-bottom: 1px solid var(--border); }
    .tab { flex: 1; text-align: center; padding: .5rem; cursor: pointer; }
    .tab[aria-selected="true"] { font-weight: 700; border-bottom: 2px solid var(--accent); }

    .panel { overflow: auto; padding: .5rem; }
    .list { list-style: none; margin: 0; padding: 0; }
    .list li { padding: .35rem .25rem; border-radius: .35rem; cursor: pointer; }
    .list li:hover { background: color-mix(in oklab, var(--accent) 18%, transparent); }

	/* === TTS highlight === */
	.tts-current { background: color-mix(in oklab, var(--accent) 35%, transparent); transition: background .2s ease; }
	

    main {
      grid-area: main;
      min-width: 0; /* allow content to shrink */
      min-height: 0; /* allow to scroll */
      display: grid;
      grid-template-rows: 1fr;
    }

    .page {
      margin: 0 auto;
      width: min(100%, var(--page-max));
      padding: 1.25rem var(--pad) 3rem;
      overflow: auto;
    }

    .page h1, .page h2, .page h3 { line-height: 1.25; }
    .page h1 { font-size: 1.6rem; margin: 0 0 1rem; }
    .page h2 { font-size: 1.25rem; margin: 2rem 0 0.75rem; }
    .page p { text-align: justify; hyphens: auto; }

    footer {
      grid-area: footer;
      display: flex; gap: 1rem; align-items: center;
      padding: .5rem var(--pad);
      border-top: 1px solid var(--border);
      position: sticky;
      bottom: 0;
      background: var(--bg);
      z-index: 5;
      color: var(--muted);
      font-size: .9rem;
    }
    .progress {
      height: .4rem; flex: 1; background: var(--border); border-radius: 999px; position: relative;
    }
    .progress > span { position: absolute; inset: 0 0 0 0; width: var(--pct, 0%); background: var(--accent); border-radius: 999px; }

    /* Utility */
    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }
    .muted { color: var(--muted); }

    @media (max-width: 900px) {
      .app { grid-template-columns: 1fr; grid-template-areas:
        "header"
        "main"
        "footer"; }
      aside { display: none; }
      header .title { max-width: 35vw; }
    }
  </style>
</head>
<body>
  <!-- =============================================================
       ONLINE READER MVP
       Plain‚Äëtext public domain pipeline with extreme verbosity
       ============================================================= -->
  <div class="app" id="app">
    <header>
      <div class="title" id="hdrTitle" title="Book title">Online Reader</div>
      <div class="controls">
        <label class="sr-only" for="chapterSel">Chapter</label>
        <select id="chapterSel" aria-label="Select chapter"></select>

        <label class="sr-only" for="searchBox">Search</label>
        <input id="searchBox" type="search" placeholder="Search‚Ä¶" aria-label="Search within book" />
        <button id="searchBtn" title="Search" class="icon" aria-label="Search">üîé</button>

        <button id="decreaseFont" class="icon" title="Smaller text" aria-label="Decrease font">A‚àí</button>
        <button id="increaseFont" class="icon" title="Larger text" aria-label="Increase font">A+</button>

        <button id="themeBtn" class="icon" title="Toggle theme" aria-label="Toggle theme">üåì</button>
        <button id="bookmarkBtn" class="icon" title="Add bookmark at current location" aria-label="Add bookmark">üîñ</button>
      </div>
	  
	  <!-- TTS controls (offline-capable via Web Speech API) -->
	  <div class="controls" aria-label="Read aloud controls" style="margin-left: auto; gap:.4rem">
	    <select id="voiceSel" aria-label="Voice"></select>
	    <label class="sr-only" for="rateSel">Rate</label>
	    <select id="rateSel" aria-label="Rate">
	      <option value="0.8">0.8√ó</option>
	      <option value="1" selected>1.0√ó</option>
	      <option value="1.2">1.2√ó</option>
	      <option value="1.5">1.5√ó</option>
	      <option value="1.8">1.8√ó</option>
	    </select>
	    <button id="ttsPlay" class="icon" title="Play read aloud" aria-label="Play">‚ñ∂Ô∏è</button>
	    <button id="ttsPause" class="icon" title="Pause read aloud" aria-label="Pause">‚è∏Ô∏è</button>
	    <button id="ttsStop" class="icon" title="Stop read aloud" aria-label="Stop">‚èπÔ∏è</button>
	  </div>
	  
    </header>

    <aside>
      <div class="tabs" role="tablist">
        <div class="tab" id="tab-toc" role="tab" aria-selected="true" tabindex="0">TOC</div>
        <div class="tab" id="tab-bm" role="tab" aria-selected="false" tabindex="-1">Bookmarks</div>
      </div>
      <div class="panel" id="panel-toc" role="tabpanel" aria-labelledby="tab-toc">
        <ul class="list" id="tocList"></ul>
      </div>
      <div class="panel" id="panel-bm" role="tabpanel" aria-labelledby="tab-bm" hidden>
        <ul class="list" id="bmList"></ul>
      </div>
    </aside>

    <main>
      <article class="page" id="reader" tabindex="0" aria-label="Reading area">
        <h1>Loading‚Ä¶</h1>
        <p>If this message persists, ensure that the required files exist. See the instructions block at the bottom of this file.</p>
      </article>
    </main>

    <footer>
      <div id="locText" class="muted">Section 0 of 0 ‚Ä¢ 0%</div>
      <div class="progress" aria-hidden="true"><span id="progressBar"></span></div>
      <div id="timeText" class="muted">0 min left in chapter</div>
    </footer>
  </div>

  <script>
    "use strict";
    // =============================================================
    // EXTREME VERBOSITY COMMENTS: ARCHITECTURE AND DATA FLOW
    // =============================================================
    // 1) The application expects a minimal manifest: /books/<id>/book.json
    // 2) The manifest points to a UTF‚Äë8 text file: /books/<id>/book.txt
    // 3) The loader fetches book.json, then streams book.txt
    // 4) The parser splits text into sections using heuristics for chapter headings
    // 5) The renderer displays one section at a time with a scroll view
    // 6) The state store records: theme, font size, last location, bookmarks
    // 7) The search performs a basic in‚Äëmemory substring search over sections
    // 8) The Service Worker (optional) caches app shell and book assets for offline

    // =============================================================
    // CONFIGURATION (you may change these values)
    // =============================================================
    const DEFAULT_BOOK_ID = "sample-text"; // folder name under /books
  //  const DEFAULT_MANIFEST_PATH = `/books/${DEFAULT_BOOK_ID}/book.json`;
  	const DEFAULT_MANIFEST_PATH = `book.json`;

    const DEFAULT_PREFS = {
      theme: (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) ? 'dark' : 'light',
      fontSizePx: 18,
      lastLoc: null /* format: `s{index}@{charOffset}`; here we track only section index for MVP */
    };

    // =============================================================
    // STATE SINGLETON
    // =============================================================
	
	const supportsTTS = 'speechSynthesis' in window && 'SpeechSynthesisUtterance' in window;
	
    const State = {
      manifest: null,    // loaded JSON manifest
      rawText: null,     // entire book text (string)
      sections: [],      // array<Section>
      currentSection: 0, // index into sections
      prefs: loadPrefs(),
      bookmarks: loadBookmarks(),
      wpm: 230,          // average words per minute for reading time estimate
tts: { enabled: true, section: 0, sentenceIdx: 0, voiceURI: null, rate: 1.0, speaking: false },
	  	
    };

    // Section type (for reference):
    // { id: string, title?: string, html: string, wordCount: number, startOffset: number }

    // =============================================================
    // PERSISTENCE LAYER
    // =============================================================
    function loadPrefs() {
      try {
        const raw = localStorage.getItem('reader.prefs');
        if (!raw) return { ...DEFAULT_PREFS };
        const parsed = JSON.parse(raw);
        return { ...DEFAULT_PREFS, ...parsed };
      } catch (e) {
        console.warn('Failed to parse prefs, using defaults', e);
        return { ...DEFAULT_PREFS };
      }
    }

    function savePrefs() {
      localStorage.setItem('reader.prefs', JSON.stringify(State.prefs));
    }

    function loadBookmarks() {
      try {
        const raw = localStorage.getItem('reader.bookmarks.' + DEFAULT_BOOK_ID);
        return raw ? JSON.parse(raw) : [];
      } catch (e) {
        console.warn('Failed to parse bookmarks');
        return [];
      }
    }

    function saveBookmarks() {
      localStorage.setItem('reader.bookmarks.' + DEFAULT_BOOK_ID, JSON.stringify(State.bookmarks));
    }

    // =============================================================
    // UTILITY FUNCTIONS
    // =============================================================
    function $(sel) { return document.querySelector(sel); }
    function el(tag, attrs = {}, children = []) {
      const n = document.createElement(tag);
      for (const [k, v] of Object.entries(attrs)) {
        if (k === 'dataset') { for (const [dk, dv] of Object.entries(v)) n.dataset[dk] = dv; continue; }
        if (k.startsWith('on') && typeof v === 'function') { n.addEventListener(k.slice(2), v); continue; }
        if (v === true) { n.setAttribute(k, ''); continue; }
        if (v === false || v == null) continue;
        n.setAttribute(k, v);
      }
      for (const c of [].concat(children)) {
        if (typeof c === 'string') n.appendChild(document.createTextNode(c)); else if (c) n.appendChild(c);
      }
      return n;
    }

    function wordsCount(s) {
      return (s.match(/\b\w+\b/g) || []).length;
    }

    function estimateMinutes(words, wpm) {
      return Math.max(1, Math.ceil(words / Math.max(100, wpm)));
    }

    function applyTheme(theme) {
      document.documentElement.setAttribute('data-theme', theme);
    }

    function applyFontSize(px) {
      document.documentElement.style.setProperty('--font-size', px + 'px');
    }

    function truncate(s, n) {
      return s.length > n ? s.slice(0, n - 1) + '‚Ä¶' : s;
    }

    // =============================================================
    // LOADER
    // =============================================================
    async function loadManifest(path = DEFAULT_MANIFEST_PATH) {
      const res = await fetch(path);
      if (!res.ok) throw new Error('Failed to load manifest: ' + res.status);
      const json = await res.json();
      State.manifest = json;
      $('#hdrTitle').textContent = json.title || 'Untitled';
      document.title = (json.title || 'Untitled') + ' ‚Äî Online Reader';
      return json;
    }

    async function loadTextFile(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error('Failed to load text: ' + res.status);
      // Stream may be used for very large files; for simplicity we read as text
      const txt = await res.text();
      // Normalize line endings and remove BOM if present
      return txt.replace(/^\uFEFF/, '').replace(/\r\n?/g, '\n');
    }

    // =============================================================
    // PARSER / SEGMENTER (simple heuristics for plain text)
    // =============================================================
    function segmentIntoSections(raw, hints = {}) {
      const out = [];
      const lines = raw.split('\n');
      const chapterRe = hints.chapterRegex ? new RegExp(hints.chapterRegex, 'i') : /^(chapter|volume)\s+[ivxlcdm0-9]+/i;

      let buffer = [];
      let startOffset = 0;
      let offset = 0;
      let currentTitle = null;

      function flushSection(force = false) {
        if (buffer.length === 0 && !force) return;
        const text = buffer.join('\n').trim();
        if (text.length === 0 && !force) { buffer = []; return; }
        const html = text
          .split(/\n\n+/)
          .map(p => `<p>${escapeHtml(p)}</p>`) // very conservative HTML
          .join('\n');
        const wc = wordsCount(text);
        out.push({ id: 's' + out.length, title: currentTitle || undefined, html, wordCount: wc, startOffset });
        startOffset = offset;
        buffer = [];
        currentTitle = null;
      }

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const isChapter = chapterRe.test(line.trim());
        // When a new chapter header is detected, flush the previous section.
        if (isChapter) {
          flushSection();
          currentTitle = toTitleCase(line.trim());
        }
        buffer.push(line);
        offset += line.length + 1; // +1 for the split newline
      }
      flushSection(true);

      // If no chapter headers were found, create virtual sections every ~3000 chars
      if (out.length <= 1) {
        return virtualChunkSections(raw);
      }
      return out;
    }

    function virtualChunkSections(raw, chunkSize = 3000) {
      const out = [];
      let pos = 0;
      while (pos < raw.length) {
        const slice = raw.slice(pos, pos + chunkSize);
        const html = slice.split(/\n\n+/).map(p => `<p>${escapeHtml(p)}</p>`).join('\n');
        out.push({ id: 's' + out.length, title: undefined, html, wordCount: wordsCount(slice), startOffset: pos });
        pos += chunkSize;
      }
      return out;
    }

    function escapeHtml(s) {
      return s
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;');
    }

    function toTitleCase(s) {
      return s.toLowerCase().replace(/(^|\s|-|:)\p{L}/gu, m => m.toUpperCase());
    }

    // =============================================================
    // RENDERER
    // =============================================================
    function renderSection(idx) {
      if (idx < 0 || idx >= State.sections.length) return;
      State.currentSection = idx;

      const sec = State.sections[idx];
      const container = $('#reader');
      container.innerHTML = '';

      if (sec.title) {
        container.appendChild(el('h1', {}, [sec.title]));
      } else {
        container.appendChild(el('h1', { class: 'muted' }, ['Section ' + (idx + 1)]));
      }

      // Insert sanitized HTML. We created it ourselves, so assign via innerHTML.
      const frag = document.createElement('div');
      frag.innerHTML = sec.html;
      container.appendChild(frag);
	  // Prepare TTS sentence map for this section (if supported)
	  container._ttsData = supportsTTS ? splitSentencesFrom(frag) : null;
	  

      // Update progress and footer metadata
      const pct = Math.round(((idx + 1) / State.sections.length) * 100);
      $('#progressBar').style.setProperty('--pct', pct + '%');
      $('#locText').textContent = `Section ${idx + 1} of ${State.sections.length} ‚Ä¢ ${pct}%`;
      const mins = estimateMinutes(sec.wordCount, State.wpm);
      $('#timeText').textContent = `${mins} min left in chapter`;

      // Persist last location
      State.prefs.lastLoc = `s${idx}@0`;
      savePrefs();

      // Maintain the select dropdown and highlight current item in TOC
      const sel = $('#chapterSel');
      if (sel.selectedIndex !== idx) sel.selectedIndex = idx;

      for (const li of document.querySelectorAll('#tocList li')) {
        li.setAttribute('aria-current', li.dataset.idx == idx ? 'true' : 'false');
      }

      // Focus reading area for keyboard navigation
      container.focus();
    }

    // =============================================================
    // UI POPULATION
    // =============================================================
    function buildTOC(sections) {
      const ul = $('#tocList');
      ul.innerHTML = '';
      sections.forEach((s, i) => {
        const label = s.title ? s.title : 'Section ' + (i + 1);
        const li = el('li', { tabindex: 0, dataset: { idx: i } }, [label]);
        li.addEventListener('click', () => renderSection(i));
        li.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') renderSection(i); });
        ul.appendChild(li);
      });
    }

    function buildChapterSelect(sections) {
      const sel = $('#chapterSel');
      sel.innerHTML = '';
      sections.forEach((s, i) => {
        const label = s.title ? s.title : 'Section ' + (i + 1);
        sel.appendChild(el('option', { value: String(i) }, [truncate(label, 64)]));
      });
      sel.addEventListener('change', () => renderSection(parseInt(sel.value, 10)));
    }

    function refreshBookmarksUI() {
      const ul = $('#bmList');
      ul.innerHTML = '';
      if (State.bookmarks.length === 0) {
        ul.appendChild(el('li', { class: 'muted' }, ['No bookmarks yet.']));
        return;
      }
      State.bookmarks.forEach(bm => {
        const label = bm.label || `(Section ${bm.section + 1})`;
        const li = el('li', { tabindex: 0 }, [label]);
        li.addEventListener('click', () => renderSection(bm.section));
        li.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') renderSection(bm.section); });
        ul.appendChild(li);
      });
    }

    function addCurrentBookmark() {
      const section = State.currentSection;
      const label = prompt('Bookmark label (optional):', State.sections[section].title || `Section ${section + 1}`);
      State.bookmarks.push({ id: String(Date.now()), section, label: label || undefined, createdAt: Date.now() });
      saveBookmarks();
      refreshBookmarksUI();
    }

    // =============================================================
    // SEARCH (simple, in‚Äëmemory, per section)
    // =============================================================
    function searchInBook(query) {
      if (!query || query.trim().length < 2) return [];
      const q = query.toLowerCase();
      const results = [];
      State.sections.forEach((s, i) => {
        // Strip tags from HTML to get plain text
        const text = s.html.replace(/<[^>]+>/g, ' ');
        const pos = text.toLowerCase().indexOf(q);
        if (pos >= 0) {
          const start = Math.max(0, pos - 40);
          const end = Math.min(text.length, pos + q.length + 40);
          const snippet = text.slice(start, end).replaceAll('\n', ' ');
          results.push({ section: i, snippet });
        }
      });
      return results.slice(0, 50);
    }

    function showSearchResults(items) {
      // Reuse TOC panel to display quick results under the search box popup style
      const ul = $('#tocList');
      ul.innerHTML = '';
      if (items.length === 0) {
        ul.appendChild(el('li', { class: 'muted' }, ['No matches.']));
        return;
      }
      items.forEach(r => {
        const label = State.sections[r.section].title || `Section ${r.section + 1}`;
        const li = el('li', { tabindex: 0 }, [label + ' ‚Äî ' + truncate(r.snippet, 120)]);
        li.addEventListener('click', () => renderSection(r.section));
        li.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') renderSection(r.section); });
        ul.appendChild(li);
      });
    }

    // =============================================================
    // KEYBOARD SHORTCUTS
    // =============================================================
    function handleKeys(e) {
      if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.isContentEditable)) return;
      switch (e.key) {
        case 'ArrowRight':
        case 'PageDown':
        case ']':
          renderSection(Math.min(State.sections.length - 1, State.currentSection + 1));
          break;
        case 'ArrowLeft':
        case 'PageUp':
        case '[':
          renderSection(Math.max(0, State.currentSection - 1));
          break;
        case '+':
          State.prefs.fontSizePx = Math.min(28, State.prefs.fontSizePx + 1); applyFontSize(State.prefs.fontSizePx); savePrefs();
          break;
        case '-':
          State.prefs.fontSizePx = Math.max(14, State.prefs.fontSizePx - 1); applyFontSize(State.prefs.fontSizePx); savePrefs();
          break;
        case 'b':
        case 'B':
          addCurrentBookmark();
          break;
        case 't':
        case 'T':
          State.prefs.theme = (State.prefs.theme === 'dark') ? 'light' : 'dark'; applyTheme(State.prefs.theme); savePrefs();
          break;
      }
    }

    // =============================================================
    // TABS (TOC <-> Bookmarks)
    // =============================================================
    function setupTabs() {
      const tabTOC = $('#tab-toc');
      const tabBM = $('#tab-bm');
      const panTOC = $('#panel-toc');
      const panBM = $('#panel-bm');
      function select(which) {
        const isTOC = which === 'toc';
        tabTOC.setAttribute('aria-selected', isTOC ? 'true' : 'false');
        tabBM.setAttribute('aria-selected', isTOC ? 'false' : 'true');
        panTOC.hidden = !isTOC;
        panBM.hidden = isTOC;
        (isTOC ? tabTOC : tabBM).setAttribute('tabindex', '0');
        (isTOC ? tabBM : tabTOC).setAttribute('tabindex', '-1');
      }
      tabTOC.addEventListener('click', () => select('toc'));
      tabBM.addEventListener('click', () => select('bm'));
      tabTOC.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') select('toc'); });
      tabBM.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') select('bm'); });
      select('toc');
    }
	// ===== TTS helpers (offline via system voices) =====
	function clearTTSHighlight() {
	  document.querySelectorAll('.tts-current').forEach(n => n.classList.remove('tts-current'));
	}

	function splitSentencesFrom(container) {
	  const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, {
	    acceptNode: (n) => n.nodeValue && n.nodeValue.trim().length ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT
	  });
	  const texts = [];
	  while (walker.nextNode()) texts.push(walker.currentNode);

	  const joined = texts.map(n => n.nodeValue).join('\n');
	  const parts = joined.split(/(?<=[.!?])\s+(?=[A-Z0-9"'(\[])|\n{2,}/g).filter(Boolean);

	  const sentences = [];
	  let tIdx = 0, offsetInNode = 0;
	  function consume(len) {
	    let remaining = len, startNode = tIdx, startOff = offsetInNode;
	    while (remaining > 0 && tIdx < texts.length) {
	      const node = texts[tIdx];
	      const available = node.nodeValue.length - offsetInNode;
	      if (remaining < available) { offsetInNode += remaining; remaining = 0; }
	      else { remaining -= available; tIdx++; offsetInNode = 0; }
	    }
	    return { startNode, startOff, endNode: tIdx, endOff: offsetInNode };
	  }

	  for (const s of parts) {
	    const rng = consume(s.length + 1);
	    sentences.push({ text: s.trim(), ...rng });
	  }
	  return { sentences, texts };
	}

	function populateVoices() {
	  if (!supportsTTS) return;
	  const sel = document.getElementById('voiceSel');
	  if (!sel) return;
	  sel.innerHTML = '';
	  const voices = speechSynthesis.getVoices().filter(v => v.lang.startsWith('en') || v.localService);
	  voices.forEach(v => sel.appendChild(el('option', { value: v.voiceURI }, [v.name + (v.localService ? ' (offline)' : '')])));
	  const saved = State.tts.voiceURI;
	  if (saved) sel.value = saved;
	  if (!sel.value && voices[0]) sel.value = voices[0].voiceURI;
	}

	function ttsSpeakCurrent(fromSentence = null) {
	  if (!supportsTTS) return;
	  const container = document.getElementById('reader');
	  const data = container._ttsData;
	  if (!data || data.sentences.length === 0) return;
	  if (fromSentence != null) State.tts.sentenceIdx = fromSentence;

	  const s = data.sentences[State.tts.sentenceIdx];
	  if (!s) {
	    if (State.currentSection < State.sections.length - 1) {
	      renderSection(State.currentSection + 1);
	      State.tts.sentenceIdx = 0;
	      ttsSpeakCurrent(0);
	    }
	    return;
	  }

	  const u = new SpeechSynthesisUtterance(s.text);
	  const voiceSel = document.getElementById('voiceSel');
	  const selectedURI = voiceSel ? voiceSel.value : null;
	  const voice = speechSynthesis.getVoices().find(v => v.voiceURI === selectedURI);
	  if (voice) u.voice = voice;

	  const rateSel = document.getElementById('rateSel');
	  u.rate = rateSel ? parseFloat(rateSel.value || '1') : 1;

	  clearTTSHighlight();
	  try {
	    const range = document.createRange();
	    const startNode = data.texts[s.startNode];
	    const endNode = data.texts[Math.min(s.endNode, data.texts.length - 1)];
	    range.setStart(startNode, s.startOff);
	    range.setEnd(endNode, Math.max(0, s.endOff));
	    const mark = document.createElement('mark'); mark.className = 'tts-current';
	    range.surroundContents(mark);
	    mark.scrollIntoView({ block: 'center', behavior: 'smooth' });
	  } catch {}

	  u.onend = () => { State.tts.sentenceIdx++; ttsSpeakCurrent(); };
	  u.onerror = () => { State.tts.speaking = false; };

	  speechSynthesis.cancel();
	  speechSynthesis.speak(u);
	  State.tts.speaking = true;
	  State.tts.voiceURI = selectedURI;
	  State.tts.rate = u.rate;
	  savePrefs();
	}

	function ttsPause() { if (supportsTTS) speechSynthesis.pause(); }
	function ttsResume() { if (supportsTTS) speechSynthesis.resume(); }
	function ttsStop() { if (supportsTTS) { speechSynthesis.cancel(); clearTTSHighlight(); State.tts.speaking = false; } }


    // =============================================================
    // BOOTSTRAP
    // =============================================================
    async function boot() {
      // Apply initial preferences
      applyTheme(State.prefs.theme);
      applyFontSize(State.prefs.fontSizePx);

      // Wire UI controls
      $('#themeBtn').addEventListener('click', () => { State.prefs.theme = (State.prefs.theme === 'dark') ? 'light' : 'dark'; applyTheme(State.prefs.theme); savePrefs(); });
      $('#increaseFont').addEventListener('click', () => { State.prefs.fontSizePx = Math.min(28, State.prefs.fontSizePx + 1); applyFontSize(State.prefs.fontSizePx); savePrefs(); });
      $('#decreaseFont').addEventListener('click', () => { State.prefs.fontSizePx = Math.max(14, State.prefs.fontSizePx - 1); applyFontSize(State.prefs.fontSizePx); savePrefs(); });
      $('#bookmarkBtn').addEventListener('click', addCurrentBookmark);
	  if (supportsTTS) {
	    $('#ttsPlay').addEventListener('click', () => ttsSpeakCurrent(State.tts.sentenceIdx || 0));
	    $('#ttsPause').addEventListener('click', () => (speechSynthesis.paused ? ttsResume() : ttsPause()));
	    $('#ttsStop').addEventListener('click', ttsStop);
	    $('#rateSel').addEventListener('change', () => { if (State.tts.speaking) ttsSpeakCurrent(State.tts.sentenceIdx); });
	    $('#voiceSel').addEventListener('change', () => { if (State.tts.speaking) ttsSpeakCurrent(State.tts.sentenceIdx); });
	    populateVoices();
	  }
	  
      $('#searchBtn').addEventListener('click', () => { const q = $('#searchBox').value; showSearchResults(searchInBook(q)); });
      $('#searchBox').addEventListener('keydown', (e) => { if (e.key === 'Enter') { const q = e.target.value; showSearchResults(searchInBook(q)); } });
      document.addEventListener('keydown', handleKeys);
      setupTabs();

      try {
        const manifest = await loadManifest(DEFAULT_MANIFEST_PATH);
        const textUrl = manifest.files && manifest.files.text ? manifest.files.text : `/books/${DEFAULT_BOOK_ID}/book.txt`;
        State.rawText = await loadTextFile(textUrl);

        State.sections = segmentIntoSections(State.rawText, manifest.hints || {});
        buildTOC(State.sections);
        buildChapterSelect(State.sections);
        refreshBookmarksUI();

        // Resume from last location if available
        let startIdx = 0;
        if (State.prefs.lastLoc && /^s(\d+)@/i.test(State.prefs.lastLoc)) {
          const m = State.prefs.lastLoc.match(/^s(\d+)@/i);
          startIdx = Math.min(State.sections.length - 1, parseInt(m[1], 10) || 0);
        }
        renderSection(startIdx);

        // Optionally register service worker if it exists alongside this file
        if ('serviceWorker' in navigator) {
          try { await navigator.serviceWorker.register('sw.js'); }
          catch (e) { console.info('Service Worker registration skipped:', e.message); }
        }
      } catch (e) {
        console.error(e);
        $('#reader').innerHTML = `<h1>Load error</h1><p>${escapeHtml(String(e.message || e))}</p>`;
      }
    }

    window.addEventListener('DOMContentLoaded', boot);
	if (supportsTTS && 'speechSynthesis' in window) {
	  speechSynthesis.onvoiceschanged = populateVoices; // voices come in async
	}
	
  </script>

  <!-- =============================================================
       FILES TO CREATE IN YOUR PROJECT
       =============================================================
       1) Place this HTML file anywhere, for example at /app/index.html
       2) Create a folder /books/pride-and-prejudice/
       3) Inside it, create two files:

          /books/pride-and-prejudice/book.json
          /books/pride-and-prejudice/book.txt

       4) Optional: create /app/sw.js for offline caching (see template below)

       You may host with any static server. For local testing, you may use:
       python3 -m http.server 8000

       Then open: http://localhost:8000/app/index.html
  ============================================================= -->

  <!-- Example: book.json (minimal) -->
  <!--
  {
    "id": "pride-and-prejudice",
    "title": "Pride and Prejudice",
    "authors": ["Jane Austen"],
    "license": "Public Domain",
    "lang": "en",
    "updated": "2025-10-05",
    "files": {
      "text": "/books/pride-and-prejudice/book.txt"
    },
    "hints": {
      "chapterRegex": "^(chapter|volume)\\s+[ivxlcdm0-9]+",
      "frontMatterLines": 80
    },
    "cover": "/books/pride-and-prejudice/cover.jpg",
    "approxWordCount": 122000
  }
  -->

  <!-- Example: sw.js (save as a separate file next to index.html) -->
  <!--
  const CACHE = 'reader-cache-v1';
  const ASSETS = [
    './index.html',
    './',
    // Include additional static assets if you split CSS and JS
  ];

  self.addEventListener('install', (e) => {
    e.waitUntil(caches.open(CACHE).then(c => c.addAll(ASSETS)));
  });

  self.addEventListener('activate', (e) => {
    e.waitUntil(
      caches.keys().then(keys => Promise.all(keys.filter(k => k !== CACHE).map(k => caches.delete(k))))
    );
  });

  self.addEventListener('fetch', (e) => {
    const url = new URL(e.request.url);
    // Cache‚Äëfirst for book files and app shell
    if (url.pathname.startsWith('/books/') || ASSETS.some(a => url.pathname.endsWith(a.replace('./','/app/')))) {
      e.respondWith(
        caches.match(e.request).then(hit => hit || fetch(e.request).then(res => {
          const copy = res.clone();
          caches.open(CACHE).then(c => c.put(e.request, copy));
          return res;
        }))
      );
    }
  });
  -->

</body>
</html>